dasymlp <- function(x,del.l,del.u){
coeff <- del.l*as.numeric(x<=0) + del.u*as.numeric( x>0)
out <- (coeff*exp(-abs(x)/coeff))/(del.l+del.u)
out <- ifelse(x<=0 , out, 1-out)
return(out)
}
#print(dasymlp(seq(-2,2,0.2) , 0.4,0.5))
#density
denasymlp <- function(x,del.l, del.u){
coeff <- del.l*as.numeric(x<=0) + del.u*as.numeric(x>0)
out <-  exp(-abs(x)/coeff)/(del.l + del.u)
return (out)
}
k1 = function(del.l , del.u){
k = (del.l**3)/((del.l + del.u)*(2*del.l -1 )*(1 + del.l - del.u))
return (k)
}
k2  = function(del.l,del.u){
k = ((del.l - 1)**3)/((2*del.l -1)*(del.l -del.u -1)*(2 - del.l -del.u))
return (k)
}
k3 = function(del.l, del.u){
k= (del.u**3)/((del.l + del.u)*(2*del.u -1)*(del.l - del.u -1))
return (k)
}
#k3(2,3)
k4 = function(del.l, del.u){
k = ((del.u -1)**3)/((2*del.u -1)*(1 + del.l - del.u)*(2- del.l - del.u))  # last breacket might be (2-del.u-del.u) as per paper
return (k)
}
k5 = function(del.l, del.u){
out  =  2/((1+2*del.u)*(2*del.u -3))
return (out)
}
k6 = function(del.l, del.u){
out  =   ((-12*del.u + 12*del.u*del.u  -5))/((1+2*del.u)*(1+2*del.u)*(2*del.u - 3)*(2*del.u - 3))
return (out)
}
k7 = function(del.l, del.u){
out  =  ((4*(del.u**3))/((1+2*del.u)*(1+2*del.u)*(2*del.u -1)))
return (out)
}
k8 = function(del.l, del.u){
out  =  (4*((del.u -1)**3))/((del.u-3)*(del.u-3)*(2*del.u -1))
return (out)
}
k9 = function(del.l, del.u){
out  = ((4*(del.l**3))/((1+2*del.l)*(1+2*del.l)*(2*del.l -1)))
return (out)
}
k10 = function(del.l, del.u){
out  = ((4*((del.l -1)**3))/((2*del.l -3)*(2*del.l -3)*(2*del.l -1)))
return (out)
}
k11 = function(del.l, del.u){
out  =  ((2)/((1 + 2*del.l)*(2*del.l -3)))
return (out)
}
k12 = function(del.l, del.u){
out  = (((-12*del.l + 12*(del.l**2) -5))/((1+2*del.l)*(1+2*del.l)*(2*del.l -3)*(2*del.l -3)))
return (out)
}
##########marginal used to find inv#######################
marginal  = function(x, del.l , del.u,t){
solve = function(x, del.l , del.u,t){
if(del.l == 0.5  && del.u == 0.5){
if(x<=0){
val =  abs(t - 0.5*(1-x)*exp(2*x))
}
else {
val = abs(t-   1+ 0.5*(1+x)*exp(-2*x))
}
return (val)
}
# exp(1)
# else
if(del.l == 0.5){
if(x<=0){
val =  abs(t-   (k5(del.l,del.u)*x*exp(2*x))  +  (k6(del.l,del.u)*exp(2*x)))
}
else {
val =  abs(t -  1 +  (k7(del.l,del.u)*exp(-x/del.u)) + (k8(del.l,del.u)*exp(x/(del.u-1))) )
}
return (val)
}
if(del.u == 0.5){
if(x<=0){
val = abs(t - (k9(del.l,del.u)*exp(x/del.l)) - (k10(del.l,del.u)*exp(x/(1-del.l))) )
}
else {
val  = abs(t - 1 - (k11(del.l,del.u)*x*exp(-2*x)) - (k12(del.l,del.u)*exp(-2*x)) )
}
return (val)
}
# else
if(x<=0){
val =  abs(t- (k1(del.l,del.u)*exp(x/del.l)) + (k2(del.l,del.u)*exp(x/(1-del.l))))
}
else {
val =  abs(t-  1 - (k3(del.l,del.u)*exp(-x/del.u)) + (k4(del.l,del.u)*exp(x/(del.u-1))) )
}
return (val)
}
return (sapply(x,solve , del.l = del.l, del.u = del.u,t =t))
}
#use this or newton raphson algorithm
margin.inv = function(t,del.l ,del.u ){
solve = function(t,del.l,del.u){
x = optimize(marginal , c(-20,20),tol = 1e-3, del.l = del.l, del.u = del.u, t = t)$minimum
return (x)
}
return (sapply(t, solve, del.l = del.l ,del.u = del.u))
}
# iter =0
# root = 13
# while(tol > epsilon && iter <1000){
#     iter = iter +1
#     curr = root - marginal(root , 0.2, 0.3)/f.dash(root)
#     tol = abs(root - curr)
#     root = curr
# }
# root
#integrand
inte = function(r,x1 ,x2,rho,del.l,del.u){
solve = function(r,x1 ,x2,rho,del.l,del.u){
d1 <- dasymlp(x1 - r , 1 - del.l, 1 - del.u)
q1 <- ifelse(d1 < 0.5, qnorm(d1), -qnorm(1 - d1))
d2 <- dasymlp(x2 - r , 1 - del.l, 1 - del.u)
q2 <- ifelse(d2 < 0.5, qnorm(d2), -qnorm(1 - d2))
#q = c(qnorm(dasymlp(x1 - r , 1- del.l, 1-del.u)) , qnorm(dasymlp(x2-r , 1- del.l, 1-del.u)))
q <- c(q1, q2)
gcop =  pmvnorm(mean = c(0,0),corr  = matrix(c(1,rho,rho,1), nrow =2),lower = -Inf,upper = q)
igrand = gcop[1]*denasymlp(r,del.l ,del.u)
return (igrand)
}
return(sapply(r,solve,x1 =x1 ,x2 =x2, rho = rho, del.l =del.l ,del.u =del.u))
}
# integration
C.t.t  = function(t1,t2,rho,del.l,del.u) {
x1 = margin.inv(t1,del.l, del.u)
x2 = margin.inv(t2,del.l , del.u)
#Integration gives  Joint Distribution F(x1,x2)
solve = function(x1,x2,rho,del.l,del.u){
return (integrate(inte, lower = -Inf, upper = Inf, x1 =x1 ,x2 =x2, rho = rho,del.l = del.l ,del.u =del.u)$value)
}
return (mapply(solve, x1,x2, rho =rho , del.l= del.l ,del.u =del.u))
}
#likelihood to estimate parameters
#1. empirical distribution to calc (u1,u2)
x1 = c(3,4,3,5,3,4,2)
x2 = c(3,5,5,6,7,5,4)
pdat1 <- function(x,x1){
return(sum(x1 <= x)/(length(x1) +1))
}
pdat2 <- function(x,x2){
return(sum(x2 <= x)/(length(x2) +1))
}
del.l = 0.1
del.u = 0.1
rho = 0.2
W <- rmvnorm(100, mean = c(0,0), sigma = matrix(c(1, rho, rho, 1), nrow = 2))
qasymlp <- function(p, del.l, del.u){
cutoff <- del.l / (del.l + del.u)
part1 <- (del.l + del.u) / (del.l * as.numeric(p <= cutoff) + del.u * as.numeric(p > cutoff))
part2 <- ifelse(p <= cutoff, log(p), log(1 - p))
part3 <- (del.l * as.numeric(p <= cutoff) - del.u * as.numeric(p > cutoff))
out <- part3 * (log(part1) + part2)
out}
R <- qasymlp(runif(100), del.l, del.u)
X <- W + R
X <- apply(X, 2, rank) / 101
den.integrand <- function(r, x1, x2, rho, del.l, del.u){
d1 <- dasymlp(x1 - r , 1 - del.l, 1 - del.u)
q1 <- ifelse(d1 < 0.5, qnorm(d1), -qnorm(1 - d1))
d2 <- dasymlp(x2 - r , 1 - del.l, 1 - del.u)
q2 <- ifelse(d2 < 0.5, qnorm(d2), -qnorm(1 - d2))
q <- cbind(q1, q2)
out <- dmvnorm(q, mean = c(0, 0), sigma = matrix(c(1, rho, rho, 1), nrow = 2))
out <- out * denasymlp(x1 - r, 1 - del.l, 1 - del.u) *
denasymlp(x2 - r, 1 - del.l, 1 - del.u) * denasymlp(r, del.l, del.u)
out <- out / (dnorm(dasymlp(x1 - r, 1 - del.l, 1 - del.u)) *
dnorm(dasymlp(x2 - r, 1- del.l, 1 - del.u)))
out}
d.joint <- function(x1, x2, rho, del.l, del.u){
integrate(den.integrand, lower = max(x1, x2) - 10, upper = min(x1, x2) + 10,
x1 = x1, x2 = x2, rho = rho, del.l = del.l, del.u = del.u)$value
}
d.marginal = function(x,del.l,del.u){
solve = function(x,del.l,del.u){
#more cases of del.l = 1/2 and del.u =1/2 and ....
if(del.l == 0.5 && del.u == 0.5){
if(x<=0){
out =   ((1-x)*exp(2*x)) - (0.5*exp(2*x))
return (out)
}
else {
out = ((1+x)*exp(-2*x)) - (0.5*exp(-2*x))
return (out)
}
}
# complete it
if(del.l ==0.5){
if(x<=0){
out = (k5(del.l ,del.u)*(exp(2*x)*(1+2*x))) - (k6(del.l,del.u)*2*exp(2*x))
return (out)
}
else {
out = (((k7(del.l ,del.u)/del.u)*exp(-x/del.u))) + (((k8(del.l,del.u)/(1-del.u))*exp(-x/(1-del.u))))
return (out)
}
}
if(del.u ==0.5){
if(x<=0){
out  = (((k9(del.l,del.u)/del.l)*exp(x/del.l))) + (((k10(del.l ,del.u)/(1-del.l))*exp(x/(1-del.l))))
return (out)
}
else {
out = (k11(del.l, del.u)*exp(-2*x)*(1-2*x)) - ((2*k12(del.l, del.u)*exp(-2*x)) )
return (out)
}
}
##########
if(x<=0){
out = ( (k1(del.l,del.u)/del.l)*exp(x/del.l)) - ((k2(del.l,del.u)/(1-del.l))*exp(x/(1-del.l)) )
return (out)
}
else {
out = ((-k3(del.l,del.u)/del.u)*exp(-x/del.u)) +   ((k4(del.l,del.u)/(1-del.u))*exp(x/(del.u -1)))
return (out)
}
}
return (sapply(x,solve,del.l =del.l, del.u =del.u))
}
c.u1.u2 <- function(u1, u2, rho, del.l, del.u){
x.1 <- margin.inv(u1, del.l, del.u)
x.2 <- margin.inv(u2, del.l, del.u)
out <- d.joint(x.1, x.2,rho,del.l , del.u) /
(d.marginal(x.1, del.l, del.u) * d.marginal(x.2, del.l, del.u))
out}
#3. likelihood
neg.log <- function(params){
sum(sapply(1:nrow(X), function(i){
- log(c.u1.u2(X[i, 1], X[i, 2], #pdat1(x1[i],x1),pdat2(x2[i],x2),
(exp(params[1])-1)/(exp(params[1]) +1),
1/(1+exp(-params[2])),
1/(1+exp(-params[3]))))}))}
optim(c(0,0,0), neg.log)
#k3(2,3)
k4 = function(del.l, del.u){
k = ((del.u -1)**3)/((2*del.u -1)*(1 + del.l - del.u)*(2- del.u - del.u))  # last breacket might be (2-del.u-del.u) as per paper
return (k)
}
optim(c(0,0,0), neg.log)
1/(1+exp(-4.802692)
)
1/(1+exp(--3.969350))
1/(1+exp(-3.969350))
1/(1+exp(3.969350))
margin.inv(0.999,0.3,0.4)
del.l = 0.3
del.u = 0.4
rho = 0.5
W <- rmvnorm(100, mean = c(0,0), sigma = matrix(c(1, rho, rho, 1), nrow = 2))
qasymlp <- function(p, del.l, del.u){
cutoff <- del.l / (del.l + del.u)
part1 <- (del.l + del.u) / (del.l * as.numeric(p <= cutoff) + del.u * as.numeric(p > cutoff))
part2 <- ifelse(p <= cutoff, log(p), log(1 - p))
part3 <- (del.l * as.numeric(p <= cutoff) - del.u * as.numeric(p > cutoff))
out <- part3 * (log(part1) + part2)
out}
R <- qasymlp(runif(100), del.l, del.u)
X <- W + R
X <- apply(X, 2, rank) / 101
den.integrand <- function(r, x1, x2, rho, del.l, del.u){
d1 <- dasymlp(x1 - r , 1 - del.l, 1 - del.u)
q1 <- ifelse(d1 < 0.5, qnorm(d1), -qnorm(1 - d1))
d2 <- dasymlp(x2 - r , 1 - del.l, 1 - del.u)
q2 <- ifelse(d2 < 0.5, qnorm(d2), -qnorm(1 - d2))
q <- cbind(q1, q2)
out <- dmvnorm(q, mean = c(0, 0), sigma = matrix(c(1, rho, rho, 1), nrow = 2))
out <- out * denasymlp(x1 - r, 1 - del.l, 1 - del.u) *
denasymlp(x2 - r, 1 - del.l, 1 - del.u) * denasymlp(r, del.l, del.u)
out <- out / (dnorm(dasymlp(x1 - r, 1 - del.l, 1 - del.u)) *
dnorm(dasymlp(x2 - r, 1- del.l, 1 - del.u)))
out}
d.joint <- function(x1, x2, rho, del.l, del.u){
integrate(den.integrand, lower = max(x1, x2) - 10, upper = min(x1, x2) + 10,
x1 = x1, x2 = x2, rho = rho, del.l = del.l, del.u = del.u)$value
}
d.marginal = function(x,del.l,del.u){
solve = function(x,del.l,del.u){
#more cases of del.l = 1/2 and del.u =1/2 and ....
if(del.l == 0.5 && del.u == 0.5){
if(x<=0){
out =   ((1-x)*exp(2*x)) - (0.5*exp(2*x))
return (out)
}
else {
out = ((1+x)*exp(-2*x)) - (0.5*exp(-2*x))
return (out)
}
}
# complete it
if(del.l ==0.5){
if(x<=0){
out = (k5(del.l ,del.u)*(exp(2*x)*(1+2*x))) - (k6(del.l,del.u)*2*exp(2*x))
return (out)
}
else {
out = (((k7(del.l ,del.u)/del.u)*exp(-x/del.u))) + (((k8(del.l,del.u)/(1-del.u))*exp(-x/(1-del.u))))
return (out)
}
}
if(del.u ==0.5){
if(x<=0){
out  = (((k9(del.l,del.u)/del.l)*exp(x/del.l))) + (((k10(del.l ,del.u)/(1-del.l))*exp(x/(1-del.l))))
return (out)
}
else {
out = (k11(del.l, del.u)*exp(-2*x)*(1-2*x)) - ((2*k12(del.l, del.u)*exp(-2*x)) )
return (out)
}
}
##########
if(x<=0){
out = ( (k1(del.l,del.u)/del.l)*exp(x/del.l)) - ((k2(del.l,del.u)/(1-del.l))*exp(x/(1-del.l)) )
return (out)
}
else {
out = ((-k3(del.l,del.u)/del.u)*exp(-x/del.u)) +   ((k4(del.l,del.u)/(1-del.u))*exp(x/(del.u -1)))
return (out)
}
}
return (sapply(x,solve,del.l =del.l, del.u =del.u))
}
c.u1.u2 <- function(u1, u2, rho, del.l, del.u){
x.1 <- margin.inv(u1, del.l, del.u)
x.2 <- margin.inv(u2, del.l, del.u)
out <- d.joint(x.1, x.2,rho,del.l , del.u) /
(d.marginal(x.1, del.l, del.u) * d.marginal(x.2, del.l, del.u))
out}
#3. likelihood
neg.log <- function(params){
sum(sapply(1:nrow(X), function(i){
- log(c.u1.u2(X[i, 1], X[i, 2], #pdat1(x1[i],x1),pdat2(x2[i],x2),
(exp(params[1])-1)/(exp(params[1]) +1),
1/(1+exp(-params[2])),
1/(1+exp(-params[3]))))}))}
optim(c(0,0,0), neg.log)
(exp(-2.3625795)-1)/(exp(-2.3625795) +1)
1/(1+exp(-2.9003642)
)
d.marginal = function(x,del.l,del.u){
solve = function(x,del.l,del.u){
#more cases of del.l = 1/2 and del.u =1/2 and ....
if(del.l == 0.5 && del.u == 0.5){
if(x<=0){
out =   ((1-x)*exp(2*x)) - (0.5*exp(2*x))
return (out)
}
else {
out = ((1+x)*exp(-2*x)) - (0.5*exp(-2*x))
return (out)
}
}
# complete it
else   if(del.l ==0.5){
if(x<=0){
out = (k5(del.l ,del.u)*(exp(2*x)*(1+2*x))) - (k6(del.l,del.u)*2*exp(2*x))
return (out)
}
else {
out = (((k7(del.l ,del.u)/del.u)*exp(-x/del.u))) + (((k8(del.l,del.u)/(1-del.u))*exp(-x/(1-del.u))))
return (out)
}
}
else  if(del.u ==0.5){
if(x<=0){
out  = (((k9(del.l,del.u)/del.l)*exp(x/del.l))) + (((k10(del.l ,del.u)/(1-del.l))*exp(x/(1-del.l))))
return (out)
}
else {
out = (k11(del.l, del.u)*exp(-2*x)*(1-2*x)) - ((2*k12(del.l, del.u)*exp(-2*x)) )
return (out)
}
}
##########
else {
if(x<=0){
out = ( (k1(del.l,del.u)/del.l)*exp(x/del.l)) - ((k2(del.l,del.u)/(1-del.l))*exp(x/(1-del.l)) )
return (out)
}
else {
out = ((-k3(del.l,del.u)/del.u)*exp(-x/del.u)) +   ((k4(del.l,del.u)/(1-del.u))*exp(x/(del.u -1)))
return (out)
}
}
}
return (sapply(x,solve,del.l =del.l, del.u =del.u))
}
d.marginal = function(x,del.l,del.u){
solve = function(x,del.l,del.u){
#more cases of del.l = 1/2 and del.u =1/2 and ....
if(del.l == 0.5 && del.u == 0.5){
if(x<=0){
out =   ((1-x)*exp(2*x)) - (0.5*exp(2*x))
return (out)
}
else {
out = ((1+x)*exp(-2*x)) - (0.5*exp(-2*x))
return (out)
}
}
# complete it
else   if(del.l ==0.5){
if(x<=0){
out = (k5(del.l ,del.u)*(exp(2*x)*(1+2*x))) - (k6(del.l,del.u)*2*exp(2*x))
return (out)
}
else {
out = (((k7(del.l ,del.u)/del.u)*exp(-x/del.u))) + (((k8(del.l,del.u)/(1-del.u))*exp(-x/(1-del.u))))
return (out)
}
}
else  if(del.u ==0.5){
if(x<=0){
out  = (((k9(del.l,del.u)/del.l)*exp(x/del.l))) + (((k10(del.l ,del.u)/(1-del.l))*exp(x/(1-del.l))))
return (out)
}
else {
out = (k11(del.l, del.u)*exp(-2*x)*(1-2*x)) - ((2*k12(del.l, del.u)*exp(-2*x)) )
return (out)
}
}
##########
else {
if(x<=0){
out = ( (k1(del.l,del.u)/del.l)*exp(x/del.l)) - ((k2(del.l,del.u)/(1-del.l))*exp(x/(1-del.l)) )
return (out)
}
else {
out = ((-k3(del.l,del.u)/del.u)*exp(-x/del.u)) +   ((k4(del.l,del.u)/(1-del.u))*exp(x/(del.u -1)))
return (out)
}
}
}
return (sapply(x,solve,del.l =del.l, del.u =del.u))
}
##########marginal used to find inv#######################
marginal  = function(x, del.l , del.u,t){
solve = function(x, del.l , del.u,t){
if(del.l == 0.5  && del.u == 0.5){
if(x<=0){
val =  abs(t - 0.5*(1-x)*exp(2*x))
}
else {
val = abs(t-   1+ 0.5*(1+x)*exp(-2*x))
}
return (val)
}
# exp(1)
# else
else  if(del.l == 0.5){
if(x<=0){
val =  abs(t-   (k5(del.l,del.u)*x*exp(2*x))  +  (k6(del.l,del.u)*exp(2*x)))
}
else {
val =  abs(t -  1 +  (k7(del.l,del.u)*exp(-x/del.u)) + (k8(del.l,del.u)*exp(x/(del.u-1))) )
}
return (val)
}
else if(del.u == 0.5){
if(x<=0){
val = abs(t - (k9(del.l,del.u)*exp(x/del.l)) - (k10(del.l,del.u)*exp(x/(1-del.l))) )
}
else {
val  = abs(t - 1 - (k11(del.l,del.u)*x*exp(-2*x)) - (k12(del.l,del.u)*exp(-2*x)) )
}
return (val)
}
# else
else {
if(x<=0){
val =  abs(t- (k1(del.l,del.u)*exp(x/del.l)) + (k2(del.l,del.u)*exp(x/(1-del.l))))
}
else {
val =  abs(t-  1 - (k3(del.l,del.u)*exp(-x/del.u)) + (k4(del.l,del.u)*exp(x/(del.u-1))) )
}
return (val)
}
}
return (sapply(x,solve , del.l = del.l, del.u = del.u,t =t))
}
optim(c(0,0,0), neg.log)
#use this or newton raphson algorithm
margin.inv = function(t,del.l ,del.u ){
solve = function(t,del.l,del.u){
x = optimize(marginal , c(-Inf,Inf),tol = 1e-3, del.l = del.l, del.u = del.u, t = t)$minimum
return (x)
}
return (sapply(t, solve, del.l = del.l ,del.u = del.u))
}
optim(c(0,0,0), neg.log)
#use this or newton raphson algorithm
margin.inv = function(t,del.l ,del.u ){
solve = function(t,del.l,del.u){
x = optimize(marginal , c(-40,40),tol = 1e-3, del.l = del.l, del.u = del.u, t = t)$minimum
return (x)
}
return (sapply(t, solve, del.l = del.l ,del.u = del.u))
}
optim(c(0,0,0), neg.log)
